<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="张天宇的文字自留地">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/logo.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          C++中的零碎 - 张天宇的博客 | ztygalaxy&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://tyzhang.top/article/algorithm0/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/beantech.min.css">


    
<link rel="stylesheet" href="/css/donate.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script>
	</script>
	<style>
	* {
            box-sizing: border-box;
        }

        form {
            position: relative;
            width: 100%;
            margin: 0 auto;
        }

        input, button {
            border: none;
            outline: none;
        }

        input {
            width: 100%;
            height: 42px;
            padding-left: 13px;
        }

        button {
            height: 42px;
            width: 42px;
            cursor: pointer;
            position: absolute;
        }

        /*搜索框1*/
        .bar1 {
			background: #FFF;
			max-width: 200px;
		}
        .bar1 input {
			max-height: 30px;
            border: 2px solid #BFBFBF;
            border-radius: 5px;
            background: #FFFFFF;
            color: #BFBFBF;
			-webkit-text-fill-color: #BFBFBF;
        }
        .bar1 button {
			max-height: 30px;
            top: 0;
            right: 0;
            background: #BFBFBF;
            border-radius: 0 5px 5px 0;
        }
        .bar1 button:before {
            content: "\f002";
            font-family: FontAwesome;
            font-size: 16px;
            color: #F9F0DA;
        }
		</style>
<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/feed.xml" title="张天宇的博客" type="application/atom+xml">
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('https://api.dujin.org/bing/1920.php')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#基础知识" title="基础知识">基础知识</a>
                            
                        </div>
                        <h1>C++中的零碎</h1>
                        <!-- <h2 class="subheading">记录算法刷题路上遇到的C++零碎问题和知识，边走边学。</h2> -->
                        <span class="meta">
                            张天宇 on
                            2019-10-17
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">ztygalaxy</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">主页</a>
                    </li>
					<li>
                        <a href="/archive/">归档</a>
                    </li>
					<li>
                        <a href="/tags/">标签</a>
                    </li>
					<li>
                        <a href="/about/">关于</a>
                    </li>
					<!--
					修改about在前面的问题
                    
                        
                    
                        
                    
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">归档</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">标签</a>
                        </li>
                        
                    
                    -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				
                <p>记录算法刷题路上遇到的C++零碎问题和知识，边走边学。</p>
<h2><span id="编程规范">编程规范</span></h2>
<h3><span id="1-语句顺序">1. 语句顺序</span></h3>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">last</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> temp = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; pos; i--) nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    nums[pos] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    nums1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums2[i] &gt;= nums1[pos] &amp;&amp; pos &lt;= m + i) &#123;<span class="comment">//问题出现了</span></span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="number">0</span>) pos -= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">last</span>(nums1, pos);</span><br><span class="line">        nums1[pos] = nums2[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法在VSCode上面没有检查出来，正常输出了。但是提交到LeetCode后发现，数组越界。经过仔细检查发现问题出在注释那一行。Pos在本程序是不能等于m+n的，但是当循环执行了最后一次后，pos=m+n再次进入while，先判断的是&amp;&amp;前面的，即出现了nums[pos]=nums[m+n]，导致越界。</p>
<p>因此该语句需要修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pos &lt;= m + i &amp;&amp; nums2[i] &gt;= nums1[pos]) &#123;</span><br><span class="line">            pos++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的还有Java中的字符串先判空再判空串“”。</p>
<h2><span id="函数使用">函数使用</span></h2>
<h3><span id="1-vector的基本用法">1. vector的基本用法</span></h3>
<h4><span id="1-排序">1. 排序</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h4><span id="2-删除">2. 删除</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="comment">//1（需要#include &lt;algorithm&gt;）</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter=<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">3</span>);</span><br><span class="line">a.<span class="built_in">erase</span>(iter);</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">2</span>);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(;it != vec.<span class="built_in">end</span>();)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*it == <span class="number">5</span>)</span><br><span class="line">        <span class="comment">//删除指定元素，返回指向删除元素的下一个元素的位置的迭代器</span></span><br><span class="line">        it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//迭代器指向下一个元素位置</span></span><br><span class="line">        ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="3-查找">3. 查找</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找指定元素位置</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line">iter = <span class="built_in">find</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), target);</span><br><span class="line"><span class="keyword">if</span> (iter != nums.<span class="built_in">end</span>()) resu = <span class="built_in">distance</span>(nums.<span class="built_in">begin</span>(), iter);</span><br></pre></td></tr></table></figure>
<h4><span id="4-截取">4. 截取</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vector&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//截取前4个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator first1 = vector.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator last1  = vector.<span class="built_in">begin</span>() + <span class="number">4</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut1_vector</span><span class="params">(first1, last1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\ncut1_vector: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> el : cut1_vector) &#123;</span><br><span class="line">    cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//截取后4个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator first2 = vector.<span class="built_in">end</span>() - <span class="number">4</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator last2  = vector.<span class="built_in">end</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cut2_vector</span><span class="params">(first2, last2)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\ncut2_vector: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> el : cut2_vector) &#123;</span><br><span class="line">   cout &lt;&lt; el &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="5-去重">5. 去重</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vector.<span class="built_in">begin</span>(),vector.<span class="built_in">end</span>());</span><br><span class="line">vector.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vector.<span class="built_in">begin</span>(),vector.<span class="built_in">end</span>()), vector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3><span id="2-字符串全排列和全组合">2. 字符串全排列和全组合</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://blog.csdn.net/nwpubear/article/details/82503917 </span></span><br><span class="line"><span class="comment">// 递归解法，第一个元素拿出来，求出后面的全排列</span></span><br><span class="line"><span class="comment">// 需要注意相同的元素不替换</span></span><br><span class="line"><span class="comment">// 但是只是相同的元素不替换不能保证所有的不重复，还需要去重</span></span><br><span class="line"><span class="comment">// 去重需要先排序，再返回去重index，然后erase即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//递归解法</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        string str2=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        str2.<span class="built_in">insert</span>(str2.<span class="built_in">end</span>(),str.<span class="built_in">begin</span>()+<span class="number">1</span>,str.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;string&gt; ret2=<span class="built_in">Permutation</span>(str2);</span><br><span class="line">        ret=<span class="built_in">changeLoc</span>(str[<span class="number">0</span>],ret2);</span><br><span class="line">        <span class="built_in">sort</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> index=<span class="built_in">unique</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">        ret.<span class="built_in">erase</span>(index,ret.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">changeLoc</span><span class="params">(<span class="type">char</span> c,vector&lt;string&gt; ret2)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(string ss:ret2)&#123;</span><br><span class="line">            ss=c+ss;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ss.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                string tmp=ss;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || c!=tmp[i])&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(tmp[<span class="number">0</span>],tmp[i]);</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="3-unorder_map">3. unorder_map</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在内部，unordered_map中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</span></span><br><span class="line"><span class="comment">//leetcode 49</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            string t = str;</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">            m[t].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(a.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">    string strs[] = &#123;<span class="string">&quot;12345&quot;</span>, <span class="string">&quot;54321&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;tae&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : strs) &#123;</span><br><span class="line">        string t = str;</span><br><span class="line">        <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">        m[t].<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="comment">//即“12345”存了“12345”“54321”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : a.second) &#123;</span><br><span class="line">            cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="4-字符串整数互转">4. 字符串整数互转</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">stol</span><span class="params">(string str)</span> </span>&#123;  </span><br><span class="line">    <span class="type">long</span> result;  </span><br><span class="line">    <span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>;  </span><br><span class="line">    is &gt;&gt; result;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">ltos</span><span class="params">(<span class="type">long</span> l)</span> </span>&#123;  </span><br><span class="line">    ostringstream os;  </span><br><span class="line">    os&lt;&lt;l;  </span><br><span class="line">    string result;  </span><br><span class="line">    <span class="function">istringstream <span class="title">is</span><span class="params">(os.str())</span></span>;  </span><br><span class="line">    is&gt;&gt;result;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3><span id="5-map的基本用法">5. Map的基本用法</span></h3>
<h4><span id="51-pair类型">5.1 pair类型</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义和初始化</span></span><br><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p</span><span class="params">(v1, v2)</span></span>;</span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2)</span><br><span class="line"><span class="comment">//取出对象值</span></span><br><span class="line">p.first</span><br><span class="line">p.second</span><br></pre></td></tr></table></figure>
<h4><span id="52-map对象">5.2 map对象</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">map&lt;k, v&gt; m;</span><br><span class="line"><span class="function">map&lt;k, v&gt; <span class="title">m</span><span class="params">(m2)</span></span>;<span class="comment">//创建了m2的副本</span></span><br><span class="line"><span class="function">map&lt;k, v&gt; <span class="title">m</span><span class="params">(b, e)</span></span>;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">mp[i] = i;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(i, i));</span><br><span class="line"><span class="comment">//查找出现次数</span></span><br><span class="line">mp.<span class="built_in">count</span>(i);</span><br><span class="line"><span class="comment">//查找key对应的值</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it_find;</span><br><span class="line">it_find = mp.<span class="built_in">find</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//删除元素k，返回删除的元素的个数</span></span><br><span class="line">m.<span class="built_in">erase</span>(k)</span><br><span class="line"><span class="comment">//删除迭代器p指向的元素，返回类型void</span></span><br><span class="line">m.<span class="built_in">erase</span>(p)</span><br><span class="line"><span class="comment">//删除迭代器b到e范围内的元素，返回类型void</span></span><br><span class="line">m.<span class="built_in">erase</span>(b, e)</span><br></pre></td></tr></table></figure>
<h3><span id="6-绝对值函数">6. 绝对值函数</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> i)</span>  <span class="comment">//返回整型参数i的绝对值 </span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cabs</span><span class="params">(<span class="keyword">struct</span> complex znum)</span>  <span class="comment">//返回复数znum的绝对值  </span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fabs</span><span class="params">(<span class="type">double</span> x)</span>  <span class="comment">//返回双精度参数x的绝对值    </span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">labs</span><span class="params">(<span class="type">long</span> n)</span>  <span class="comment">//返回长整型参数n的绝对值 </span></span></span><br></pre></td></tr></table></figure>
<h3><span id="7-字符串切割">7. 字符串切割</span></h3>
<h4><span id="1-find函数">1. find函数</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原型：<span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">( <span class="type">const</span> string&amp; str, <span class="type">size_t</span> pos = <span class="number">0</span> )</span> <span class="type">const</span></span>;</span><br><span class="line">功能：查找子字符串第一次出现的位置。</span><br><span class="line">参数说明：str为子字符串，pos为初始查找位置。</span><br><span class="line">返回值：找到的话返回第一次出现的位置，否则返回string::<span class="built_in">npos</span>(表示位置不存在的整数)</span><br></pre></td></tr></table></figure>
<h4><span id="2-substr函数">2. substr函数</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原型：<span class="function">string <span class="title">substr</span> <span class="params">( <span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> n = npos )</span> <span class="type">const</span></span>;</span><br><span class="line">功能：获得子字符串。</span><br><span class="line">参数说明：pos为起始位置（默认为<span class="number">0</span>），n为结束位置（默认为npos）</span><br><span class="line">返回值：子字符串</span><br></pre></td></tr></table></figure>
<h4><span id="3-按字符切割">3. 按字符切割</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string str, string sp)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="type">char</span> *context;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strtok</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(str.<span class="built_in">data</span>()), sp.<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">for</span> (p; p != <span class="literal">nullptr</span>; p = <span class="built_in">strtok</span>(<span class="literal">nullptr</span>, sp.<span class="built_in">data</span>())) &#123;</span><br><span class="line">        <span class="comment">//char *转string</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp, p);</span><br><span class="line">        string t = <span class="built_in">string</span>(tmp);</span><br><span class="line">        result.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="8-字符串查找系列函数">8. 字符串查找系列函数</span></h3>
<p>以下所讲的所有的string查找函数，都有唯一的返回类型，那就是size_type，即一个无符号整数（按打印出来的算）。若查找成功，返回按查找规则找到的第一个字符或子串的位置；若查找失败，返回npos，即-1（打印出来4294967295）。</p>
<h4><span id="1-find函数">1. find函数</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">st1</span><span class="params">(<span class="string">&quot;babbabab&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; st1.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;<span class="comment">//1   由原型知，若省略第2个参数，则默认从位置0（即第1个字符）起开始查找</span></span><br><span class="line">cout &lt;&lt; st1.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h4><span id="2-rfind函数">2. rfind函数</span></h4>
<p>find()是从指定位置起向前查找，直到串首。</p>
<h4><span id="3-find_first_of函数">3. find_first_of函数</span></h4>
<p>在源串中从位置pos起往后查找，只要在源串中遇到一个字符，该字符与目标串中任意一个字符相同，就停止查找，返回该字符在源串中的位置；若匹配失败，返回npos。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">&quot;bcgjhikl&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;kghlj&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str1.<span class="built_in">find_first_of</span>(str2, <span class="number">0</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4><span id="4-find_last_of函数">4. find_last_of函数</span></h4>
<p>该函数与find_first_of()函数相似，只不过查找顺序是从指定位置向前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标串中仅有字符c与源串中的两个c匹配，其余字符均不匹配</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abcdecg&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find_last_of</span>(<span class="string">&quot;hjlywkcipn&quot;</span>, <span class="number">6</span>) &lt;&lt; endl;<span class="comment">//5   从str的位置6(g)开始想前找，g不匹配，再找c，c匹配，停止查找，返回c在str中的位置5</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find_last_of</span>(<span class="string">&quot;hjlywkcipn&quot;</span>, <span class="number">4</span>) &lt;&lt; endl;<span class="comment">//2   从str的位置4(e)开始想前找，e不匹配，再找d,d不匹配，再找c，c匹配，停止查找，返回c在str中的位置5</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find_last_of</span>(<span class="string">&quot;hjlywkcipn&quot;</span>, <span class="number">200</span>) &lt;&lt; endl;<span class="comment">//5   当第2个参数超出源串的长度（这里str长度是7）时，不会出错，相当于从源串的最后一个字符起开始查找</span></span><br></pre></td></tr></table></figure>
<h4><span id="5-find_first_not_of函数">5. find_first_not_of函数</span></h4>
<p>在源串中从位置pos开始往后查找，只要在源串遇到一个字符，该字符与目标串中的任意一个字符都不相同，就停止查找，返回该字符在源串中的位置；若遍历完整个源串，都找不到满足条件的字符，则返回npos。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;kiajbvehfgmlc&quot;</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//3   从源串str的位置0(a)开始查找，目标串中有a（匹配），再找b，b匹配,再找c，c匹配，再找d，目标串中没有d（不匹配），停止查找，返回d在str中的位置3</span></span><br><span class="line"><span class="comment">//即源串中不在目标串中的第一个元素的位置</span></span><br></pre></td></tr></table></figure>
<h4><span id="6-find_last_not_of函数">6. find_last_not_of函数</span></h4>
<p>find_last_not_of()与find_first_not_of()相似，只不过查找顺序是从指定位置向前。</p>
<h3><span id="9-整数取整">9. 整数取整</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//或math.h</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">floor</span>(<span class="number">4.9</span>)&lt;&lt;endl;	<span class="comment">//4</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">ceil</span>(<span class="number">4.9</span>) &lt;&lt; endl;	<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h3><span id="10-bitset的用法及作用">10. bitset的用法及作用</span></h3>
<p>bitset用于对数字的位进行操作，将32位的数字m转换位bitset类型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">var</span><span class="params">(m)</span></span>;</span><br></pre></td></tr></table></figure>
<h4><span id="101-any">10.1 any()</span></h4>
<p>为了测试bitset 对象是否含有被设置为1的位，我们可以使用any()操作。当bitset对象的一位或多个位被设置为1 时any()返回true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">var</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; var.<span class="built_in">any</span>() &lt;&lt; endl;<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h4><span id="102-none">10.2 none()</span></h4>
<p>相反，如果bitset 对象的所有位都被设置为0 ,则none()操作返回true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">var</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; var.<span class="built_in">none</span>() &lt;&lt; endl;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h4><span id="103-count">10.3 count()</span></h4>
<p>返回被设置为1的位的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">var</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; var.<span class="built_in">count</span>() &lt;&lt; endl;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>LeetCode 11题： 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).<span class="built_in">count</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="104-set">10.4 set()</span></h4>
<p>set或者下标将某位单独设置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;3&gt; <span class="title">var</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; var.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; endl;<span class="comment">//110</span></span><br><span class="line">var[<span class="number">0</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="105-test">10.5 test()</span></h4>
<p>测试某一位，test和下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bitvec.<span class="built_in">test</span>(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">if</span> (bitvec[index])</span><br></pre></td></tr></table></figure>
<h4><span id="106-reset">10.6 reset()</span></h4>
<p>将某一位单独设置为0，reset和下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitvec.<span class="built_in">reset</span>(<span class="number">0</span>);</span><br><span class="line">bitvec[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4><span id="107-filp">10.7 filp()</span></h4>
<p>flip()操作翻转整个bitset对象或一个独立的位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitvec.<span class="built_in">flip</span>(<span class="number">0</span>); <span class="comment">// 翻转第一位</span></span><br><span class="line">bitvec[<span class="number">0</span>].<span class="built_in">flip</span>(); <span class="comment">// 也是翻转第一位</span></span><br><span class="line">bitvec.<span class="built_in">flip</span>(); <span class="comment">// 翻转所有的位的值</span></span><br></pre></td></tr></table></figure>
<h4><span id="108-其他构造方法">10.8 其他构造方法</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还有两种方法可以构造bitset 对象，它们都提供了将某位初始化为1的方式：</span></span><br><span class="line"><span class="comment">//一种方法是为构造函数显式地提供一个无符号参数。bitset 对象的前N 位被初始化为参数的相应位值，例如：</span></span><br><span class="line"><span class="function">bitset&lt; 32 &gt; <span class="title">bitvec2</span><span class="params">( <span class="number">0xffff</span> )</span></span>;</span><br><span class="line"><span class="comment">//将bitvec2 的低16 位设为1</span></span><br><span class="line"><span class="comment">//下面的bitvec3 的定义</span></span><br><span class="line"><span class="function">bitset&lt; 32 &gt; <span class="title">bitvec3</span><span class="params">( <span class="number">012</span> )</span></span>;</span><br><span class="line"><span class="comment">//将第1 和3 位的值设置为1 假设位置从0 开0</span></span><br><span class="line"><span class="comment">//因为 012 在c语言中表示八进制数字12即二进制数字“1010”</span></span><br><span class="line"><span class="comment">//我们还可以传递一个代表0 和1 的集合的字符串参数来构造bitset 对象如下所示</span></span><br><span class="line"><span class="comment">// 与bitvec3 的初始化等价</span></span><br><span class="line"><span class="function">string <span class="title">bitval</span><span class="params">( <span class="string">&quot;1010&quot;</span> )</span></span>;</span><br><span class="line"><span class="function">bitset&lt; 32 &gt; <span class="title">bitvec4</span><span class="params">( bitval )</span></span>;</span><br><span class="line"><span class="comment">//bitvec4 和bitvec3 的第1 和3 位都被设置为1 而其他位保持为0</span></span><br><span class="line">bitvec.<span class="built_in">set</span>();</span><br></pre></td></tr></table></figure>
<h2><span id="数据结构">数据结构</span></h2>
<h3><span id="1-树的基本操作">1. 树的基本操作</span></h3>
<p><a href="https://blog.csdn.net/monster_ii/article/details/82115772">参考链接</a></p>
<h4><span id="11-树的定义">1.1 树的定义</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TreeNode</span> *right;</span><br><span class="line">&#125;TreeNode;</span><br></pre></td></tr></table></figure>
<h4><span id="12-树的遍历">1.2 树的遍历</span></h4>
<h5><span id="121-前序遍历">1.2.1 前序遍历</span></h5>
<ol>
<li>递归写法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(<span class="type">const</span> TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;                 <span class="comment">//若结点为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);        <span class="comment">//输出根节点的值</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;left);             <span class="comment">//前序访问左子树</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;right);            <span class="comment">//前序访问右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>非递归写法</p>
<p>如果存在左孩子，就一路将左孩子压入栈，直到叶子节点。分别作top操作访问右孩子。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrderLoop</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur, *top;</span><br><span class="line">    cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, cur-&gt;data);</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        top = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cur = top-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="122-中序遍历">1.2.2 中序遍历</span></h5>
<ol>
<li>递归写法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(<span class="type">const</span> TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;              <span class="comment">//判断节点是否为空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;left);           <span class="comment">//中序遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);     <span class="comment">//访问节点值</span></span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;right);          <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>非递归写法</p>
<p>保存节点自身和它的右子树都没有被访问的节点地址。</p>
<p>cur指针一路沿着最左边往下访问，路过的节点全部压栈，直到遇到空节点。从栈中取出栈顶节点top，输出栈顶结点的值并使cur = top-&gt;right，从第一步开始去遍历top的右子树。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrderLoop</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur;</span><br><span class="line">    cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, cur-&gt;data);</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="123-后序遍历">1.2.3 后序遍历</span></h5>
<ol>
<li>递归写法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>非递归写法</p>
<p>沿着左子树一路往下走，将路过的节点都压栈，直到走到空节点。然后从栈中看一下栈顶元素（只看一眼，用top指针记下，先不出栈），如果top节点没有右子树，或者last等于top的右孩子，说明top的右子树不存在或者遍历过了，就输出top节点的值，并将栈顶元素pop掉（出栈），反之则是从左子树回到根节点的，接下来要去右子树。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrderLoop</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    std::stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur, *top, *last = <span class="literal">NULL</span>;</span><br><span class="line">    cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        top = s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (top-&gt;right == <span class="literal">NULL</span> || top-&gt;right == last)&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, top-&gt;data);</span><br><span class="line">            last = top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = top-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="124-层序遍历">1.2.4 层序遍历</span></h5>
<p>层序遍历的思路是，创建一个队列，先将根节点（A）入队，然后用front指针将根节点记下来，再将根节点出队，接下来看front节点（也就是刚才的根节点）有没有左孩子或右孩子，如果有，先左（B）后右（C）入队，最后输出front节点的值，只要队列还不为空，就说明还没有遍历完，就进行下一次循环，这时的队头元素（front）则为刚才入队的左孩子（B），然后front出队，再把它的左右孩子拉进来（如果有），因为队列的先进先出性质，B的左右孩子DE是排在C后面的，然后输出B，下一次循环将会拉人C的左右孩子FG，最后因为FG没有左右孩子，一直出队，没有入队元素，队列迟早会变为空，当队列为空时，整颗树就层序遍历完成了，结束循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    std::queue&lt;TreeNode *&gt; q;</span><br><span class="line">    TreeNode *front;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        front = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">            q.<span class="built_in">push</span>(front-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(front-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, front-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="其他">其他</span></h2>
<h3><span id="1-指针地址">1. 指针地址</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p, a = <span class="number">10</span>;  p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>*p表示指针p</p>
<p>&amp;a表示取a的内存地址</p>
<p>p = &amp;a 表示p等于a的内存地址</p>
<p>&amp;*p表示获取指针p的内存地址</p>
<p>*&amp;p表示指向P内存地址的一个指针</p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/webhook/" data-toggle="tooltip" data-placement="top" title="WebHook自动拉取服务器代码">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/birth/" data-toggle="tooltip" data-placement="top" title="十">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">编程规范</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">1. 语句顺序</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">函数使用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">1. vector的基本用法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">1. 排序</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">2. 删除</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">3. 查找</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.4.</span> <span class="toc-nav-text">4. 截取</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.1.5.</span> <span class="toc-nav-text">5. 去重</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2. 字符串全排列和全组合</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.3.</span> <span class="toc-nav-text">3. unorder_map</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.4.</span> <span class="toc-nav-text">4. 字符串整数互转</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.5.</span> <span class="toc-nav-text">5. Map的基本用法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.5.1.</span> <span class="toc-nav-text">5.1 pair类型</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.5.2.</span> <span class="toc-nav-text">5.2 map对象</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.6.</span> <span class="toc-nav-text">6. 绝对值函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.7.</span> <span class="toc-nav-text">7. 字符串切割</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.7.1.</span> <span class="toc-nav-text">1. find函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.7.2.</span> <span class="toc-nav-text">2. substr函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.7.3.</span> <span class="toc-nav-text">3. 按字符切割</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.8.</span> <span class="toc-nav-text">8. 字符串查找系列函数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.1.</span> <span class="toc-nav-text">1. find函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.2.</span> <span class="toc-nav-text">2. rfind函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.3.</span> <span class="toc-nav-text">3. find_first_of函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.4.</span> <span class="toc-nav-text">4. find_last_of函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.5.</span> <span class="toc-nav-text">5. find_first_not_of函数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.8.6.</span> <span class="toc-nav-text">6. find_last_not_of函数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.9.</span> <span class="toc-nav-text">9. 整数取整</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">2.10.</span> <span class="toc-nav-text">10. bitset的用法及作用</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.1.</span> <span class="toc-nav-text">10.1 any()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.2.</span> <span class="toc-nav-text">10.2 none()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.3.</span> <span class="toc-nav-text">10.3 count()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.4.</span> <span class="toc-nav-text">10.4 set()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.5.</span> <span class="toc-nav-text">10.5 test()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.6.</span> <span class="toc-nav-text">10.6 reset()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.7.</span> <span class="toc-nav-text">10.7 filp()</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">2.10.8.</span> <span class="toc-nav-text">10.8 其他构造方法</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">数据结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">1. 树的基本操作</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">1.1 树的定义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">1.2 树的遍历</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.1.</span> <span class="toc-nav-text">1.2.1 前序遍历</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.2.</span> <span class="toc-nav-text">1.2.2 中序遍历</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.3.</span> <span class="toc-nav-text">1.2.3 后序遍历</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link"><span class="toc-nav-number">3.1.2.4.</span> <span class="toc-nav-text">1.2.4 层序遍历</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">其他</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">1. 指针地址</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#基础知识" title="基础知识">基础知识</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
				<!--
                
                <hr>
                <h5>朋友们</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://www.freedomly.tk/" target="_blank">Freedomly</a></li>
                    
                        <li><a href="https://jlwang1996.github.io/" target="_blank">jlwang1996</a></li>
                    
                        <li><a href="http://siwenzheng.github.io/" target="_blank">SiwenZheng</a></li>
                    
                        <li><a href="https://loststartvt.github.io/" target="_blank">LostStarTvT</a></li>
                    
                        <li><a href="https://zbsong.top/" target="_blank">songzblink</a></li>
                    
                        <li><a href="https://dolnw.github.io/" target="_blank">JCWang</a></li>
                    
                </ul>
                
				-->
            </div>
        </div>
    </div>
</article>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


<!-- chrome Firefox 中文锚点定位失效-->
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
<!-- smooth scroll behavior polyfill  -->
<script type="text/javascript" src="/js/smoothscroll.js"></script>
<script>
        $('#toc').on('click','a',function(a){
            // var isChrome = window.navigator.userAgent.indexOf("Chrome") !== -1;
            // console.log(window.navigator.userAgent,isChrome)
                // if(isChrome) {
                    // console.log(a.currentTarget.outerHTML);
                    // console.log($(a.currentTarget).attr("href"));
                    //跳转到指定锚点
                    // document.getElementById(a.target.innerText.toLowerCase()).scrollIntoView(true);
                    document.getElementById($(a.currentTarget).attr("href").replace("#","")).scrollIntoView({behavior: 'smooth' });
                // }
        })  
</script>


    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhang-tian-yu-65-49">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                
				
                    <li>
                        <a target="_blank" href="https://space.bilibili.com/38534865">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse"><b>B</b></i>
                            </span>
                        </a>
                    </li>
                
				
                    <li>
                        <a target="_blank" href="https://m.okjike.com/users/28c5ee85-832c-4a04-ab73-788a507d2bd8">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse"><b>J</b></i>
                            </span>
                        </a>
                    </li>
                
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/ztygalaxy">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 张天宇 2024 
                    <br>
                    Theme by <a href="http://www.huweihuang.com">Huwei Huang</a>
                    re-Ported by <a href="https://github.com/ztygalaxy">ztygalaxy</a>
					
					<br>
                    <a href="http://beian.miit.gov.cn/" style="color: gray">浙 ICP备19045818号</a>
					<br>
					<!-- <p class="copyright text-muted" style="margin-top: 5px"> -->
						<img src="../../img/备案图标.png"/>
						<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33011802001883" style="color: gray">浙公网安备 33011802001883号</a>
					<!-- </p> -->
					
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://tyzhang.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://tyzhang.top/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
